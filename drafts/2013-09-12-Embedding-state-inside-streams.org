#+TITLE: 2013-09-09-Embedding-state-inside-streams
#+DATE: <2013-09-11 Wed>
#+AUTHOR: aki
#+EMAIL: aki@utahraptor.local
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not LOGBOOK) date:t e:t
#+OPTIONS: email:nil f:t inline:t num:t p:nil pri:nil stat:t tags:t
#+OPTIONS: tasks:t tex:t timestamp:t toc:t todo:t |:t
#+CREATOR: Emacs 24.3.1 (Org mode 8.0.3)
#+DESCRIPTION:
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: en
#+SELECT_TAGS: export

Continuing this series on streams and readers in ML is a short post on something I touched on last time: how to attach line and column numbers to tokens produced by a lexical analyzer. At first glance, this seems pretty tricky. Recall that the reader interface is basically a peek function. A reader just decomposes a stream into the first element and the rest. There's no way to know where we are in the stream.

Let's define a simple record for our position:

#+BEGIN_SRC sml
  type pos = {line: int, col: int}
#+END_SRC

#+RESULTS:
: type pos = {col:int, line:int}

It might suffice to use a pair of integers (i.e. `int * int`) for this instead of a record, but it's really sort of a matter of taste.

We would like to be able to do something like the following:

#+BEGIN_SRC sml
  case rdr s of
      NONE => ...
    | SOME ((x, {line, col}), s') => ...
#+END_SRC

Here, `rdr` is a reader, and `s` is a stream, whose element type includes a position for that element. Remember that the type of reader is `'b -> ('a * 'b) option`. So what we want is some kind of reader with the type `'b -> (('a * pos) * 'b) option`.

This gives us a couple of hints. The stream needs to know the current position, and the reader needs to be able to extract the position to return it. We need to construct a new type of stream and a new type of reader. More precisely, we need some way of transforming an existing type of stream and an accompanying reader into a positional stream and a positional reader.

Let's start with transforming the streams. We're looking for a function that takes a stream and returns the same stream transformed in some way to keep track of the current position. This is deceptively simple:

#+BEGIN_SRC sml
  fun startStream s = (s, {line = 1, col = 1})
#+END_SRC

#+RESULTS:
: val startStream = fn : 'a -> 'a * {col:int, line:int}

The idea is that we take a stream that's at the beginning of a file (whether it's actually a file handle or not is of course irrelevant but line and column number is inherently sort of file-centric information) and return the stream unchanged along with a position. The result is just a pair of stream and position. But that's our new, position-aware stream type. In other words, given a stream of type `'a`, a positional stream just has the type `'a * pos`.

Now we need a function that takes a reader and returns a new reader, which keeps track of position for us. Restricting ourselves to character streams for the time being, what we want is a function with the type:

#+BEGIN_SRC sml
  val posReader: (char,'a) StringCvt.reader -> (char * pos,'a * pos) StringCvt.reader
#+END_SRC

Notice that we interpret the type of the new reader as a reader producing values of type `char * pos` from streams of type `'a * pos`. In other words, the positional reader will only work on positional streams. Before we implement `posReader`, let's write a couple of little functions to operator on position records:

#+BEGIN_SRC sml
  fun incrLine ({line, col} : pos) : pos = {line = line + 1, col = 1}
  fun incrCol ({line, col} : pos) : pos = {line = line, col = col + 1}
#+END_SRC

#+RESULTS:
: val incrLine = fn : pos -> pos
: val incrCol = fn : pos -> pos

Now, here's the implementation of `posReader`:

#+BEGIN_SRC sml
  fun posReader rdr =
      fn (s, p) =>
         case rdr s of
             NONE => NONE
           | SOME (#"\n", s') => SOME ((#"\n", p), (s', incrLine p))
           | SOME (x, s') => SOME ((x, p), (s', incrCol p))
#+END_SRC

#+RESULTS:
: val posReader = fn
:   : ('a -> (char * 'b) option)
:     -> 'a * pos -> ((char * pos) * ('b * pos)) option

I've chosen to return newlines with the position of the line previous, i.e. newlines are the last character on each line before the next line begins. I guess this too is a matter of taste, but the alternative doesn't make sense to me. Here's an example of using the new positional reader:

#+BEGIN_SRC sml
  - val s = (Substring.full "foo\nbar", {line = 1, col = 1} : pos) ;
  val s = (-,{col=1,line=1}) : substring * pos
  - val rdr = posReader Substring.getc ;
  val rdr = fn : substring * pos -> ((char * pos) * (substring * pos)) option
  - rdr s ;
  val it = SOME ((#"f",{col=1,line=1}),(-,{col=2,line=1}))
    : ((char * pos) * (substring * pos)) option
  - Reader.consume rdr s ;
  val it =
    [(#"f",{col=1,line=1}),(#"o",{col=2,line=1}),(#"o",{col=3,line=1}),
     (#"\n",{col=4,line=1}),(#"b",{col=1,line=2}),(#"a",{col=2,line=2}),
     (#"r",{col=3,line=2})] : (char * pos) list
#+END_SRC

If you look closely at the last result, you'll see that the positions returned for each character are correct.

It's not too much work to adapt the Scheme lexer from the last post to use positional readers and attach positions to the tokens it produces. First, the type of `tokenize` will have to change, to reflect that we're working with positional readers and streams:

#+BEGIN_SRC sml
  val tokenize : (char * pos, 'a * pos) StringCvt.reader -> (token * pos, 'a * pos) StringCvt.reader
#+END_SRC

The implementation of `tokenize` isn't really much different. It just has to carry position information over from characters to tokens:

#+BEGIN_SRC sml
  fun tokenize rdr =
      fn s =>
         case rdr (skipWS rdr s) of
             NONE => NONE
           | SOME ((#".", p), s') => SOME ((Dot, p), s')
           | SOME ((#"(", p), s') => SOME ((LParen, p), s')
           | SOME ((#")", p), s') => SOME ((RParen, p), s')
           | SOME (_, s') =>
             case getAtom rdr (StringCvt.skipWS rdr s) of
                 NONE => NONE
               | SOME ((atom, p), s') => SOME ((Atom atom, p), s')
#+END_SRC

Of course, `getAtom` has to be refactored to handle positions too:

#+BEGIN_SRC sml
  fun getAtom rdr s =
      let
         fun return [] _ = NONE
           | return acc p s = SOME ((String.implode (rev acc), p), s)
                                 
         fun getAtom' acc s =
             case rdr s of
                 NONE => return acc s
               | SOME ((#"(", _), rest) => return acc s
               | SOME ((#")", _), rest) => return acc s
               | SOME ((x, p), rest) => if Char.isSpace x then
                                           return acc s
                                        else getAtom' (x :: acc) rest
      in
         getAtom' [] s
      end
  
#+END_SRC
